import datetime
import json
import timeit
from collections import defaultdict

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import unitary_group
from qiskit import Aer, execute, IBMQ
from qiskit.aqua import QuantumInstance
from qiskit.aqua.algorithms import QPE
from qiskit.aqua.algorithms.classical import ExactEigensolver
from qiskit.aqua.components.iqfts import Standard
from qiskit.aqua.components.initial_states import Custom
from qiskit.aqua.operators import MatrixOperator
from qiskit.providers import BaseBackend
from qiskit.providers.ibmq import least_busy
from qiskit.result.result import Result


class QuantumPhaseEstimation:
    def __init__(self, matrix: np.ndarray):
        """ A class for experimenting Qiskit Quantum Phase Estimation (QPE)
        
        Args:
            matrix (np.ndarray): unitary matrix with even features
        """
        self.matrix = np.array([[]])
        self.__prepare_input(matrix)

    def __prepare_input(self, matrix: np.ndarray):
        """ Checks if the input matrix is valid and convert its entries into float to avoid errors.
        
        Args:
            matrix (np.ndarray): unitary matrix with even features
        
        Raises:
            ValueError: raise an error if the input is not a two dimensional array
            ValueError: raise an error if the input does not have even features
            ValueError: raise an error if the input does not satisfy another Hamiltotnian charateristic
        """
        if len(matrix.shape) != 2:
            raise ValueError("Input is not a two dimensional array.")
        if len(matrix) % 2 != 0:
            # check hamiltonian characteristic 1
            raise ValueError("Input does not satisfy the Hamiltotnian charateristic of being a 2n-by-2n matrix.")
        
        # matn = len(matrix) // 2
        # In = np.identity(matn)
        # zeros = np.zeros((matn, matn))
        # top = np.concatenate((zeros, In), axis=1)
        # bottom = np.concatenate((-In, zeros), axis=1)
        # J = np.concatenate((top, bottom), axis=0)
        # if not np.allclose(J.dot(matrix).conj().T, J.dot(matrix)):
        #     # check hamiltonian characteristic 2
        #     raise ValueError("Input does not satisfy the Hamiltotnian charateristic of np.allclose(J.dot(matrix).conj().T, J.dot(matrix))")
        # if not np.allclose(matrix.dot(matrix.conj().T), np.identity(len(matrix))):
        #     # check unitary characteristic
        #     raise ValueError("Input is not a unitary matrix.")
        self.matrix = matrix.astype(complex)

    def print_input_matrix(self):
        print(f"INPUT:\n{self.matrix}")

    def calc_classical_eig(self, 
                           print_results: bool = False, 
                           solver: str = "exact_solver") -> list:
        """ Prints Eigenvalues generated by the selected classical algorithm.
        
        Args:
            print_results (bool, optional): print the eigenvalues or not. Defaults to False.
            solver (str, optional): can be "exact_solver" or "numpy". Defaults to "exact_solver"
        """
        results = []
        print("=======TRADITIONAL=======")
        if solver == "exact_solver":
            # Classical Eigensolver in Qiskit
            eig_solver = ExactEigensolver(MatrixOperator(self.matrix), 2)
            results = eig_solver.run()['eigvals']
            print("EXACTSOLVER:", results)
        elif solver == "numpy":
            # Classical Eigenvalue Decomposition in NumPy
            results = list(np.linalg.eig(self.matrix)[0])
            print("EIGENVALUES:", results)
            # print("EIGENVECTORS:", list(list(item) for item in np.linalg.eig(matrix)[1]))
        else:
            print("No solver found. Check your solver name.")
        print("=========================")
        return results

    def run_qpe_algo(self,
                     num_ancillae: int = 1,
                     backend: BaseBackend = None,
                     print_eig: bool = False,
                     shots: int = 1024) -> dict:
        """ Runs the QPE algorithm directly.
        
        Args:
            num_ancillae (int, optional): ancillary qubit number, the higher the more accurate, but use more computing resources. Defaults to 1.
            backend (BaseBackend, optional): Choose the backend to run this algorithm. Defaults to None.
            print_eig (bool, optional): whether or not print the eigenvalue. Defaults to False.
            shots (int, optional): Indicate how many shots to take. Defaults to 1024.
        
        Returns:
            dict: returns the results dictionary of the QPE algorithm. Use the 'energy' key to get the eigenvalue.
        """
        if backend is None: # Default backend to Aer.get_backend('qasm_simulator').
            backend = Aer.get_backend('qasm_simulator')
        # QPE
        m, n = self.matrix.shape
        qpe = QPE(operator=MatrixOperator(matrix=self.matrix),
                  state_in=Custom(m),
                  iqft=Standard(num_ancillae),
                  num_time_slices=50,
                  num_ancillae=num_ancillae,
                  expansion_mode='suzuki',
                  expansion_order=2,
                  shallow_circuit_concat=True)
        results = qpe.run(QuantumInstance(backend=backend, skip_qobj_validation=False, shots=shots))
        if print_eig: print("ENERGY:", results['energy'])
        return results

    def execute_qpe_circuit(self,
                            num_ancillae: int = 1, 
                            backend: BaseBackend = None,
                            shots: int = 1024,
                            print_eig: bool = False) -> Result:
        """Runs the QPE algorithm by constructing the circuit explicitly.
        
        Args:
            num_ancillae (int, optional): ancillary qubit number, the higher the more accurate, but use more computing resources. Defaults to 1.
            backend (BaseBackend, optional): Choose the backend to run this algorithm. Defaults to None.
            shots (int, optional): Indicate how many shots to take. Defaults to 1024.
            print_eig (bool, optional): whether or not print the eigenvalue. Defaults to False.
        
        Returns:
            Result: returns a Qiskit.result object. Use get_counts() to get a dictionary for the qubits' probabilities.
        """
        if backend is None: # Default backend to Aer.get_backend('qasm_simulator').
            backend = Aer.get_backend('qasm_simulator')
        # QPE Circuit
        m, n = self.matrix.shape
        qpe = QPE(operator=MatrixOperator(matrix=self.matrix),
                  state_in=Custom(m),
                  iqft=Standard(num_ancillae),
                  num_time_slices=50,
                  num_ancillae=num_ancillae,
                  expansion_mode='suzuki',
                  expansion_order=2,
                  shallow_circuit_concat=True)
        results = execute(qpe.construct_circuit(measurement=True),
                          backend=backend).result()
        if print_eig: print(results.get_counts())
        return results


def euler(x):
    return complex(np.cos(x), np.sin(x))


def matrix_gen_pt(method="phi_theta", phi_deg=0, theta_deg=0):
    print(f"Phi:{phi_deg}, Theta:{theta_deg}")
    phi, theta = np.deg2rad(phi_deg), np.deg2rad(theta_deg)
    a = np.cos(theta)
    b = -np.sin(theta) * euler(-phi)
    c = np.sin(theta) * euler(phi)
    d = np.cos(theta)
    return np.array([[a, b],[c, d]])


if __name__ == "__main__":
    tag = ""
    # input matrix, must be unitary
    # phi_deg, theta_deg = 45, 37
    # matrix = matrix_gen_pt(phi_deg=phi_deg, theta_deg=theta_deg)

    # test
    a, b, c, d = 45, 60, 30, 45
    matrix = np.array([[euler(a), 0], [0, euler(a)]])
    tag = "[[euler(a), 0], [0, euler(a)]]"
    # matrix = np.array([[euler(a), 0, 0, 0], [0, euler(d), 0, 0], [0, 0, -euler(a).conjugate(), 0], [0, 0, 0, -euler(d).conjugate()]])
    # tag = "[[[euler(45), 0, 0, 0], [0, euler(45), 0, 0], [0, 0, -euler(45).conjugate(), 0], [0, 0, 0, -euler(45).conjugate()]]"

    # hamiltonian: A = [[a, b], [c, d]] where a + d.T == 0 and b == b.T nad c == c.T
    # matrix = np.array([[1, 3],[3, -1]])
    print("Input Matrix:")
    # print(f"Tag:{tag}")
    print(matrix)

    # setup IBMQ account if not yet
    # with open("settings.json") as f:
    #     IBMQ.save_account(json.load(f)["token"])

    # load IBMQ account and backend
    provider = IBMQ.load_account()
    backend = Aer.get_backend('qasm_simulator')
    # backend = provider.get_backend("ibmq_16_melbourne")
    # backend = provider.get_backend("ibmq_ourense")
    # backend = provider.get_backend("ibmq_qasm_simulator")
    # backend = least_busy(provider.backends(n_qubits=5, simulator=False))
    print(f"Using backend {backend}.")
    shots = 1024
    
    # initialization
    qpe = QuantumPhaseEstimation(matrix)
    num_ancillaes, eigs, min_errs, exe_times = list(range(1, 5)), [], [], []
    
    # print classical results
    qpe.calc_classical_eig(print_results=True)
    classical_eigs = qpe.calc_classical_eig(print_results=True, solver="numpy")

    time_stamp = f"{datetime.datetime.now()}, {backend.name()}"
    for num_ancillae in num_ancillaes:
        # get the results running the algorithm
        results = qpe.run_qpe_algo(num_ancillae=num_ancillae, backend=backend, shots=shots)
        # time the algorithm by running it multiple times and averaging it.
        num_of_test = 5
        # exe_time_num = 0 # reduce workload
        exe_time_num = timeit.timeit(lambda: qpe.run_qpe_algo(
                                                    num_ancillae=num_ancillae, 
                                                    backend=backend,
                                                    shots=shots),
                                     number=num_of_test) / num_of_test
        eigenvalue = euler(results['energy'])
        min_err = min(abs(eigenvalue-ceig) for ceig in classical_eigs)

        print(num_ancillae, f"{eigenvalue:.4}", f"{min_err:.4}", exe_time_num)

        # adding the results to lists
        eigs.append(eigenvalue)
        min_errs.append(min_err)
        exe_times.append(exe_time_num)

        # save the collected data
        results_dict = defaultdict(defaultdict)
        with open("results.json") as f:
            previous_record = json.load(f)
            results_dict.update(previous_record)
        with open("temp.json", "w") as f:
            results_dict[f"{tag}, {matrix.tolist()}"][str(time_stamp)] = \
                [(n, str(ei), err, ex) for (n, ei, err, ex) in zip(num_ancillaes, eigs, min_errs, exe_times)]
            json.dump(results_dict, f)
        with open("temp.json") as fin:
            with open("results.json", "w") as fout:
                json.dump(json.load(fin), fout)
        
        # progress indicator
        print(f"{num_ancillae-num_ancillaes[0]+1}/{len(num_ancillaes)} finished,", \
              f"current time: {datetime.datetime.now()}")
    
    # print the results
    print(f"Backend: {backend.name()}")
    cline = " " # column seperating line
    cwidth = 20 # column width
    print(cline.join(e.ljust(cwidth) for e in ["num_anci","eig","min err","exe time"]))
    for n, ei, err, ex in zip(num_ancillaes, eigs, min_errs, exe_times):
        print(cline.join(e.ljust(cwidth) for e in [str(n), str(f"{ei:.4}"), str(f"{err:.4}"), str(f"{ex}")]))

    # prepare the figure
    print("Figure filename:", \
          f"{backend.name()} {matrix.tolist()} anci {num_ancillaes[0]}-{num_ancillaes[-1]}")
    plt.title("QPE Experiment")

    # plt.subplot(2, 1, 1)
    plt.plot(num_ancillaes, exe_times, 'o-')
    plt.xticks(num_ancillaes)
    plt.xlabel("Ancillary Qubit Number")
    plt.ylabel("Execution time (seconds / time)")

    plt.show()

    # plt.subplot(2, 1, 2)
    plt.plot(num_ancillaes, min_errs, 'o-')
    plt.xticks(num_ancillaes)
    plt.xlabel("Ancillary Qubit Number")
    plt.ylabel("Min Error")

    plt.show()